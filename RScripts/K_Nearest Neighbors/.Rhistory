if (length <= r^2)
{
points = 1
}
else
{
points = 0
}
} #end "test.circle"
#
# Vectorize the process of determining if a point is inside or outside the circle
# by using "apply()"
# 1. Each element of "pts", row by row, is read by "apply()" and the values are
#    passed to function "test.circle".
#
circle.results=apply(pts,1,test.circle,r,cntr)
#
# If classified as "1" it is an inside point, put x,y coordinates into "inside.circle" matrix
# If classified as "0" it is an outside point,put x,y coordinates into "outside.circle" matrix
#
# Before assigning, size both "inside.circle" and "outside.circle" appropriately.
# The number of rows of "inside.circle" is equal to the number of elements
# where  "pts" == 1 divided by 2
# The number of rows of "outside.circle" is equal to the number of elements
# where "pts" == 0 divided by 2
#
# It's assumed for this application that the number of columns is equal to 2 (x/y coordinates)
#
inside.rows     <- length(pts[circle.results == 1,])/2
outside.rows    <- length(pts[circle.results == 0,])/2
inside.circle   <- matrix(pts[circle.results == 1,], nrow=inside.rows,  ncol=2)
outside.circle  <- matrix(pts[circle.results == 0,], nrow=outside.rows, ncol=2)
#
# Create a vector that has "x" and "y" points of the circle
# described by "r" and "cntr", “nseg” represents 360 degrees of circle
#
nseg=360
circle.x <- cntr[1] + r*cos( seq(0,2*pi, length.out=nseg) )
circle.y <- cntr[2] + r*sin( seq(0,2*pi, length.out=nseg) )
#
# Calculate limits of "X" and "Y" axis in plot:
# Take the union of "pts" and points on circle to calculate limits
#
total.x = c(pts[,1],circle.x)
total.y = c(pts[,2],circle.y)
x.axis = c( min(total.x) - 1, max(total.x) + 1)
y.axis = c( min(total.y) - 1, max(total.y) + 1)
#
# Make plot of axis, points in circle are red, points outside circle, blue
# and draw circle with radius "r" and center "cntr"
#
plot(x.axis,y.axis,main="Divide Points Using Circle",type="n",xlab="X",ylab="Y",
sub="Sarah Quadri")
points(circle.x,circle.y, type = 'l')
points(outside.circle, asp=1, col="purple",pch=8)
points(inside.circle, asp=1, col="green",pch=8)
#
# Specifications state to return a matrix containing points in the circle,
# If there are no points in the circle, return "NULL"
#
{
if (length(inside.circle) == 0)
{
return(NULL)
}
else
{
return(inside.circle)
}
}
} #End function.circle"
#
# Generate test data for function "in.circle"
# "pts" are some random points generated by getting 14 random numbers
# from a uniform distribution between 0 and 10 and rounding them,
# this is done twice to get an "x" coordinate and a "y" coordinate
# for 14 points
#
set.seed(40)
x = runif(14,0,10)
x = round(x,3)
y = runif(14,0,10)
y = round(y,3)
pts = cbind(x,y)
cntr = c(4,5)
r = 3.5
# Run function "in.circle"
test.in.circle = in.circle(pts,cntr,r)
library(rgl)
install.packages("rgl")
library(rgl)
install.packages("rgl")
library(rgl)
rho=0.5
mux=0
muy=0
sigmax=1
sigmay=1
# Graphing Parameters
#	deviations is the number of std. deviations included in the plot
#	partitions^2 is the total number of dots in the plot, more=blacker
#     You want to leave a lattice in areas of interest, so choose accordingly.
partitions=500
deviations=4
v1<-rep(seq((mux-deviations*sigmax), (mux+deviations*sigmax), by=((2*deviations*sigmax)/partitions)), times=partitions)
v2<-seq((muy-deviations*sigmay), (muy+deviations*sigmay), by=((2*deviations*sigmay)/partitions))
v3<-rep(v2, each=partitions)
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
install.packages("rgl", dependencies = TRUE)
library(rgl)
install.packages("knitr")
install.packages("rmarkdown")
install.packages("rgl")
library(rgl)
### imperfect particle counter
lam = 10
p = 0.9
# probability distribution
len = 5
z = matrix(0,1+len,1+len)
for(i in 0:len){
for(j in 0:i){
z[1+j,1+i] = dbinom(j,size=i,prob=p)
}
}
z
z.sum = apply(z,2,sum)
z.sum
x.mean=0
for(i in 1:len){
x.mean = c(x.mean,i*p)
}
x.mean
for(i in 0:len){
X11()
plot(z[,1+i],type="h")
}
B = 1000000
n = rpois(B,lam)
x = rbinom(n=B,size=n,prob=p)
plot(n,x,main="Counts detected vs Counts emitted, with E[X|N]")
x.fit = lm(x ~ 0+n)
summary(x.fit)
abline(x.fit)
### imperfect particle counter
lam = 10
p = 0.9
# probability distribution
len = 5
z = matrix(0,1+len,1+len)
for(i in 0:len){
for(j in 0:i){
z[1+j,1+i] = dbinom(j,size=i,prob=p)
}
}
z
z.sum = apply(z,2,sum)
z.sum
x.mean=0
for(i in 1:len){
x.mean = c(x.mean,i*p)
}
x.mean
for(i in 0:len){
X11()
plot(z[,1+i],type="h")
}
#Possible word cloud ideas
#Predictive modelling, big data, hadoop, statistical learning.
#Make comparison word cloud of the previous, as well.
library(RCurl)
# Set SSL certs globally
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
require(twitteR)
reqURL <- "https://api.twitter.com/oauth/request_token"
accessURL <- "https://api.twitter.com/oauth/access_token"
authURL <- "https://api.twitter.com/oauth/authorize"
apiKey <- "6luzxeoVHtPdvN3rERPwhDdQn"
apiSecret <- "r3YwGnBekES4ylHWmgmCHlRmJUhwmU1TvoQltjmGl2luTnSbZc"
twitCred <- OAuthFactory$new(consumerKey=apiKey,consumerSecret=apiSecret,requestURL=reqURL,accessURL=accessURL,authURL=authURL)
twitCred$handshake(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))
install.packages("RCurl")
install.packages("RCurl")
install.packages("twitteR")
library(RCurl)
# Set SSL certs globally
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
require(twitteR)
reqURL <- "https://api.twitter.com/oauth/request_token"
accessURL <- "https://api.twitter.com/oauth/access_token"
authURL <- "https://api.twitter.com/oauth/authorize"
apiKey <- "6luzxeoVHtPdvN3rERPwhDdQn"
apiSecret <- "r3YwGnBekES4ylHWmgmCHlRmJUhwmU1TvoQltjmGl2luTnSbZc"
twitCred <- OAuthFactory$new(consumerKey=apiKey,consumerSecret=apiSecret,requestURL=reqURL,accessURL=accessURL,authURL=authURL)
twitCred$handshake(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))
require(twitteR)
library(twitteR)
twitCred <- OAuthFactory$new(consumerKey=apiKey,consumerSecret=apiSecret,requestURL=reqURL,accessURL=accessURL,authURL=authURL)
twitCred$handshake(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl"))
registerTwitterOAuth(twitCred)
?setup_twitter_oauth
library(rgl)
install.packages("rgl")
install.packages("rgl")
library(rgl)
# Parameters for BVN, change as you see fit.
rho=0.5
mux=0
muy=0
sigmax=1
sigmay=1
# Graphing Parameters
#	deviations is the number of std. deviations included in the plot
#	partitions^2 is the total number of dots in the plot, more=blacker
#     You want to leave a lattice in areas of interest, so choose accordingly.
partitions=500
deviations=4
v1<-rep(seq((mux-deviations*sigmax), (mux+deviations*sigmax), by=((2*deviations*sigmax)/partitions)), times=partitions)
v2<-seq((muy-deviations*sigmay), (muy+deviations*sigmay), by=((2*deviations*sigmay)/partitions))
v3<-rep(v2, each=partitions)
# The rgl package must be installed and loaded for the following code to work!!!
# The resulting plot can be rotated by clicking and draging, the mouse wheel zooms in and out.
# Full screen is best!
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
# Code to graph and manipulable in 3-dimensions the bivariate normal distribution
# Demonstration of rgl package in R
library(rgl)
# Parameters for BVN, change as you see fit.
rho=0.5
mux=0
muy=0
sigmax=1
sigmay=1
# Graphing Parameters
#	deviations is the number of std. deviations included in the plot
#	partitions^2 is the total number of dots in the plot, more=blacker
#     You want to leave a lattice in areas of interest, so choose accordingly.
partitions=500
deviations=4
v1<-rep(seq((mux-deviations*sigmax), (mux+deviations*sigmax), by=((2*deviations*sigmax)/partitions)), times=partitions)
v2<-seq((muy-deviations*sigmay), (muy+deviations*sigmay), by=((2*deviations*sigmay)/partitions))
v3<-rep(v2, each=partitions)
# The rgl package must be installed and loaded for the following code to work!!!
# The resulting plot can be rotated by clicking and draging, the mouse wheel zooms in and out.
# Full screen is best!
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
# Code to graph and manipulable in 3-dimensions the bivariate normal distribution
# Demonstration of rgl package in R
library(rgl)
# Parameters for BVN, change as you see fit.
rho=0.5
mux=0
muy=0
sigmax=1
sigmay=1
# Graphing Parameters
#	deviations is the number of std. deviations included in the plot
#	partitions^2 is the total number of dots in the plot, more=blacker
#     You want to leave a lattice in areas of interest, so choose accordingly.
partitions=500
deviations=4
v1<-rep(seq((mux-deviations*sigmax), (mux+deviations*sigmax), by=((2*deviations*sigmax)/partitions)), times=partitions)
v2<-seq((muy-deviations*sigmay), (muy+deviations*sigmay), by=((2*deviations*sigmay)/partitions))
v3<-rep(v2, each=partitions)
# The rgl package must be installed and loaded for the following code to work!!!
# The resulting plot can be rotated by clicking and draging, the mouse wheel zooms in and out.
# Full screen is best!
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
### Probability simulation used to estimate pi = 3.14
B = 100000000
x = runif(B, min=-1, max=1)
y = runif(B, min=-1, max=1)
# check if the points (x,y) are in the unit circle x^2 + y^2 = 1
Count = 0
for(i in 1:B){
if (x[i]^2+y[i]^2 <= 1) Count = Count + 1
}
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
x = plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
x
plot(x)
# Code to graph and manipulable in 3-dimensions the bivariate normal distribution
# Demonstration of rgl package in R
library(rgl)
# Parameters for BVN, change as you see fit.
rho=0.5
mux=0
muy=0
sigmax=1
sigmay=1
# Graphing Parameters
#	deviations is the number of std. deviations included in the plot
#	partitions^2 is the total number of dots in the plot, more=blacker
#     You want to leave a lattice in areas of interest, so choose accordingly.
partitions=500
deviations=4
v1<-rep(seq((mux-deviations*sigmax), (mux+deviations*sigmax), by=((2*deviations*sigmax)/partitions)), times=partitions)
v2<-seq((muy-deviations*sigmay), (muy+deviations*sigmay), by=((2*deviations*sigmay)/partitions))
v3<-rep(v2, each=partitions)
# The rgl package must be installed and loaded for the following code to work!!!
# The resulting plot can be rotated by clicking and draging, the mouse wheel zooms in and out.
# Full screen is best!
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
library(rgl)
# Parameters for BVN, change as you see fit.
rho=0.5
mux=0
muy=0
sigmax=1
sigmay=1
# Graphing Parameters
#	deviations is the number of std. deviations included in the plot
#	partitions^2 is the total number of dots in the plot, more=blacker
#     You want to leave a lattice in areas of interest, so choose accordingly.
partitions=500
deviations=4
v1<-rep(seq((mux-deviations*sigmax), (mux+deviations*sigmax), by=((2*deviations*sigmax)/partitions)), times=partitions)
v2<-seq((muy-deviations*sigmay), (muy+deviations*sigmay), by=((2*deviations*sigmay)/partitions))
v3<-rep(v2, each=partitions)
# The rgl package must be installed and loaded for the following code to work!!!
# The resulting plot can be rotated by clicking and draging, the mouse wheel zooms in and out.
# Full screen is best!
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))), xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
?plot3d
open3d()
open3d()
plot3d(v1[1:length(v1)], v3[1:length(v3)], (1/(2*pi*sigmax*sigmay*(1-rho^2)^(.5))*exp((-1)*(1/(2*(1-rho^2)))*((((v1[1:length(v1)]-mux)/sigmax)^2)+(((v3[1:length(v3)]-muy)/sigmay)^2)-(2*rho*(((v1[1:length(v1)]-mux)*(v3[1:length(v3)]-muy))/(sigmax*sigmay)))))),
xlab="X", ylab="Y", zlab="f(x,y)", main="Bivariate Normal Distribution")
open3d()
x <- sort(rnorm(1000))
y <- rnorm(1000)
z <- rnorm(1000) + atan2(x,y)
plot3d(x, y, z, col=rainbow(1000))
open3d()
x <- sort(rnorm(20))
y <- rnorm(20)
z <- rnorm(20) + atan2(x,y)
plot3d(x, y, z, col=rainbow(20))
# Code to view correlation in pseudorandom numbers generated by a LCG
library(rgl)
# Note: This is a TERRIBLE LCG used only to show the correlation.
N=26
Seed       = 44
Mvalue     = 26
Cvalue     = 27
Dvalue     = 3
v1         = numeric(N)
v1[1]      = Seed
for (i in 2:N)
{Next = (Cvalue*Seed + Dvalue)%%Mvalue
v1[i] = Next
Seed = Next
}
v2<-v1/Mvalue
plot(v2[1:(N-1)], v2[2:N], main="Correlation of Pseudorandom Numbers from a Linear Congruential Generator")
# Note: This LCG has passed, and still passes, many tests for "randomness"
# and is suggested for use by the U.S. Bureau of Standards in 1964.
N=100000
Seed       = 762939453125
Mvalue     = 2^47
Cvalue     = (2^7)+1
Dvalue     = 29741096258473
v1         = numeric(N)
v1[1]      = Seed
for (i in 2:N)
{Next = (Cvalue*Seed + Dvalue)%%Mvalue
v1[i] = Next
Seed = Next
}
v2<-v1/Mvalue
# View correlation in 2-dimensions. X-axis is v[i-1], Y-axis is v[i].
# Expand this image to full screen to see the "structure."
plot(v2[1:(N-1)], v2[2:N], main="Correlation of Pseudorandom Numbers from a Linear Congruential Generator")
plot3d(v2[1:(N-2)], v2[2:(N-1)], v2[3:N], main="Correlation of Pseudorandom Numbers from a Linear Congruential Generator")
n = 2000
# The goal is to simulate the the
muw1 = 10
muw2 = 25
sigmaw1 = 2
sigmaw2 = 3
sigmasqw1 = sigmaw1^2
sigmasqw2 = sigmaw2^2
rhow1w2 = -0.4
covw1w2 = rhow1w2*sigmaw1*sigmaw2
# plot the BVN
mu1<-muw1 # setting the expected value of x1
mu2<-muw2 # setting the expected value of x2
s11<-sigmasqw1 # setting the variance of x1
s12<-covw1w2 # setting the covariance between x1 and x2
s22<-sigmasqw2 # setting the variance of x2
rho<-rhow1w2 # setting the correlation coefficient between x1 and x2
x1<-seq(mu1-10,mu1+10,length=41) # generating the vector series x1
x2<-seq(mu2-10,mu2+10,length=41)
f<-function(x1,x2){
term1 <- 1/(2*pi*sqrt(s11*s22*(1-rho^2)))
term2 <- -1/(2*(1-rho^2))
term3 <- (x1-mu1)^2/s11
term4 <- (x2-mu2)^2/s22
term5 <- -2*rho*((x1-mu1)*(x2-mu2))/(sqrt(s11)*sqrt(s22))
term1*exp(term2*(term3+term4-term5))
} # setting up the function of the multivariate normal density
z<-outer(x1,x2,f) # calculating the density values
persp(x1, x2, z,
main="Two dimensional Normal Distribution",
sub=expression(italic(f)~(bold(x))==frac(1,2~pi~sqrt(sigma[11]~
sigma[22]~(1-rho^2)))~phantom(0)~exp~bgroup("{",
list(-frac(1,2(1-rho^2)),
bgroup("[", frac((x[1]~-~mu[1])^2, sigma[11])~-~2~rho~frac(x[1]~-~mu[1],
sqrt(sigma[11]))~ frac(x[2]~-~mu[2],sqrt(sigma[22]))~+~
frac((x[2]~-~mu[2])^2, sigma[22]),"]")),"}")),
col="lightgreen",
theta=30, phi=20,
r=50,
d=0.1,
expand=0.5,
ltheta=90, lphi=180,
shade=0.75,
ticktype="detailed",
nticks=5) # produces the 3-D plot
# adding a text line to the graph
mtext(expression(list(mu[1]==10,mu[2]==25,sigma[11]==2,sigma[22]==3,sigma[12]==-2.4,rho==-0.4)), side=3)
# simulate independent random uniforms
u1 = runif(n)
u2 = runif(n)
X11()
par(mfrow=c(2,2))
hist(u1);hist(u2);plot(u1,u2)
umean = c(mean(u1),mean(u2));umean
usd = c(sd(u1),sd(u2));usd
ucor = cor(u1,u2);ucor
# simulate independent random normals - Box-Muller Method
x1 = sqrt(-2*log(u1))*cos(2*pi*u2)
x2 = sqrt(-2*log(u1))*sin(2*pi*u2)
X11()
par(mfrow=c(2,2))
hist(x1);hist(x2);plot(x1,x2)
xmean = c(mean(x1),mean(x2));xmean
xsd = c(sd(x1),sd(x2));xsd
xcor = cor(x1,x2);xcor
# trasnsform to correlated normals BVN(0,0,sigmasqw1,sigmassqw2,rho)
c11 = sigmaw1
c21 = rhow1w2*sigmaw2
c22 = sigmaw2*sqrt(1-rhow1w2^2)
w1 = c11*x1
w2 = c21*x1 + c22*x2
X11()
par(mfrow=c(2,2))
hist(w1);hist(w2);plot(w1,w2)
wmean = c(mean(w1),mean(w2));wmean
wsd = c(sd(w1),sd(w2));wsd
wcor = cor(w1,w2);wcor
# tansform to add means BVN(muw1,muw2,sigmasqw1,sigmassqw2,rho)
y1 = muw1 + w1
y2 = muw2 + w2
X11()
par(mfrow=c(2,2))
hist(y1);hist(y2);plot(y1,y2)
ymean = c(mean(y1),mean(y2));ymean
ysd = c(sd(y1),sd(y2));ysd
ycor = cor(y1,y2);ycor
# rotate by theta to make independent BVN(muw1,muw2,sigmasqw1,sigmassqw2,0)
theta = 0.5*atan((2*rhow1w2*sigmaw1*sigmaw2)/(sigmasqw1-sigmasqw2))
theta
v1 = y1*cos(theta) + y2*sin(theta)
v2 = -y1*sin(theta) + y2*cos(theta)
X11()
par(mfrow=c(2,2))
hist(v1);hist(v2);plot(v1,v2)
vmean = c(mean(v1),mean(v2));vmean
vsd = c(sd(v1),sd(v2));vsd
vcor = cor(v1,v2);vcor
# using the mvrnorm( ) function from the library MASS
library(MASS)
mu = c(muw1,muw2);mu
Sigma = matrix(c(sigmasqw1,covw1w2,covw1w2,sigmasqw2),2,2);Sigma
aa = mvrnorm(n, mu, Sigma)
X11()
par(mfrow=c(2,2))
hist(aa[,1]);hist(aa[,2]);plot(aa)
aamean = c(mean(aa[,1]),mean(aa[,2]));aamean
aasd = c(sd(aa[,1]),sd(aa[,2]));aasd
aacor = cor(aa[,1],aa[,2]);aacor
###################################################################
# scatterplots for large data
#  install.packages("IDPmisc", repos = "http://cran.cnr.Berkeley.edu")
library(IDPmisc)
X11()
ipairs(matrix(c(u1,u2),n,2))
X11()
ipairs(matrix(c(x1,x2),n,2))
X11()
ipairs(matrix(c(w1,w2),n,2))
X11()
ipairs(matrix(c(y1,y2),n,2))
X11()
ipairs(matrix(c(v1,v2),n,2))
X11()
ipairs(aa)
#  install.packages("gplots", repos = "http://cran.cnr.Berkeley.edu")
library(gplots)
X11()
par(mfrow=c(2,2))
hist2d(u1,u2, nbins=50, col = c("white",heat.colors(16)))
box()
hist2d(x1,x2, nbins=50, col = c("white",heat.colors(16)))
box()
hist2d(w1,w2, nbins=50, col = c("white",heat.colors(16)))
box()
hist2d(y1,y2, nbins=50, col = c("white",heat.colors(16)))
box()
X11()
install.packages("cario")
